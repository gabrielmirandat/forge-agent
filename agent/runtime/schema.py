"""Planner output schema definitions.

This module defines the structured output format for the Planner component.
All plans must conform to this schema for validation and execution.
"""

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, field_validator


class ToolName(str, Enum):
    """Allowed tool names."""

    FILESYSTEM = "filesystem"
    GIT = "git"
    GITHUB = "github"
    SHELL = "shell"
    SYSTEM = "system"


class FilesystemOperation(str, Enum):
    """Allowed filesystem operations."""

    READ_FILE = "read_file"
    WRITE_FILE = "write_file"
    LIST_DIRECTORY = "list_directory"
    CREATE_FILE = "create_file"
    DELETE_FILE = "delete_file"


class GitOperation(str, Enum):
    """Allowed Git operations."""

    CREATE_BRANCH = "create_branch"
    COMMIT = "commit"
    PUSH = "push"
    STATUS = "status"
    DIFF = "diff"


class GitHubOperation(str, Enum):
    """Allowed GitHub operations."""

    CREATE_PR = "create_pr"
    LIST_PRS = "list_prs"
    COMMENT_PR = "comment_pr"


class ShellOperation(str, Enum):
    """Allowed shell operations."""

    EXECUTE_COMMAND = "execute_command"


class SystemOperation(str, Enum):
    """Allowed system operations."""

    GET_STATUS = "get_status"
    GET_INFO = "get_info"


# Mapping of tools to their allowed operations
ALLOWED_OPERATIONS: Dict[ToolName, List[str]] = {
    ToolName.FILESYSTEM: [op.value for op in FilesystemOperation],
    ToolName.GIT: [op.value for op in GitOperation],
    ToolName.GITHUB: [op.value for op in GitHubOperation],
    ToolName.SHELL: [op.value for op in ShellOperation],
    ToolName.SYSTEM: [op.value for op in SystemOperation],
}


class PlanStep(BaseModel):
    """A single step in an execution plan."""

    step_id: int = Field(..., description="Sequential step identifier", gt=0)
    tool: ToolName = Field(..., description="Tool name to use")
    operation: str = Field(..., description="Operation to perform")
    arguments: Dict[str, Any] = Field(default_factory=dict, description="Operation arguments")
    rationale: str = Field(..., min_length=1, description="Brief explanation of this step")

    @field_validator("operation", mode="after")
    @classmethod
    def validate_operation(cls, v: str, info) -> str:
        """Validate that operation is allowed for the specified tool."""
        # Get tool from the model instance (info.data is the model instance)
        tool = info.data.get("tool") if hasattr(info, "data") else None
        if tool is None:
            # If tool is not set yet, skip validation (will be validated when tool is set)
            return v

        # Handle both enum and string tool values
        if isinstance(tool, ToolName):
            tool_name = tool
        elif isinstance(tool, str):
            try:
                tool_name = ToolName(tool)
            except ValueError:
                # Tool validation will fail separately, just return operation
                return v
        else:
            return v

        allowed_ops = ALLOWED_OPERATIONS.get(tool_name, [])

        if v not in allowed_ops:
            allowed_str = ", ".join(allowed_ops)
            raise ValueError(
                f"Operation '{v}' is not allowed for tool '{tool_name.value}'. "
                f"Allowed operations: {allowed_str}"
            )

        return v


class Plan(BaseModel):
    """Complete execution plan generated by the Planner.

    Supports both regular plans (with steps) and empty plans (no steps).
    Empty plans are valid when the Planner determines no action is needed.
    """

    plan_id: str = Field(..., min_length=1, description="Unique plan identifier")
    objective: str = Field(..., min_length=1, description="High-level goal description")
    steps: List[PlanStep] = Field(
        default_factory=list, description="Ordered list of execution steps (empty for empty plans)"
    )
    estimated_time_seconds: Optional[int] = Field(
        default=None, ge=0, description="Estimated execution time"
    )
    notes: Optional[str] = Field(
        default=None, description="Additional notes or constraints (required for empty plans)"
    )

    @field_validator("steps")
    @classmethod
    def validate_step_ids(cls, v: List[PlanStep]) -> List[PlanStep]:
        """Validate that step IDs are sequential and unique."""
        if not v:
            # Empty plan is valid - no step ID validation needed
            return v

        step_ids = [step.step_id for step in v]
        expected_ids = list(range(1, len(v) + 1))

        if step_ids != expected_ids:
            raise ValueError(
                f"Step IDs must be sequential starting from 1. "
                f"Got: {step_ids}, expected: {expected_ids}"
            )

        return v

    @field_validator("notes")
    @classmethod
    def validate_empty_plan_notes(cls, v: Optional[str], info) -> Optional[str]:
        """Validate that empty plans have explanatory notes."""
        steps = info.data.get("steps", [])
        if not steps and not v:
            raise ValueError(
                "Empty plans (no steps) must include 'notes' explaining why no action is taken."
            )
        return v


class PlannerDiagnostics(BaseModel):
    """Diagnostics information for Planner execution.

    Captures execution metadata for debugging and auditing.
    Does NOT affect plan execution - purely informational.
    """

    model_name: str = Field(..., description="LLM model name used")
    temperature: float = Field(..., description="Temperature setting used")
    retries_used: int = Field(..., ge=0, description="Number of retries attempted")
    raw_llm_response: str = Field(..., description="Raw LLM output (preserved for inspection)")
    extracted_json: Optional[str] = Field(
        default=None, description="Extracted JSON string (None if extraction failed)"
    )
    validation_errors: Optional[List[str]] = Field(
        default=None, description="Validation errors encountered (None if validation succeeded)"
    )


class PlanResult(BaseModel):
    """Complete planning result including plan and diagnostics.

    This is the return type from Planner.plan() - includes both the plan
    and diagnostic information for auditing and debugging.
    """

    plan: Plan = Field(..., description="The generated plan (may be empty)")
    diagnostics: PlannerDiagnostics = Field(..., description="Execution diagnostics")


class PlanningError(Exception):
    """Base exception for planning failures."""

    pass


class LLMCommunicationError(PlanningError):
    """Raised when LLM communication fails (network, timeout, etc.)."""

    def __init__(self, message: str, diagnostics: Optional[PlannerDiagnostics] = None):
        """Initialize LLM communication error.

        Args:
            message: Error message
            diagnostics: Optional diagnostics information
        """
        super().__init__(message)
        self.diagnostics = diagnostics


class JSONExtractionError(PlanningError):
    """Raised when JSON extraction fails (no JSON found, multiple JSON objects, etc.)."""

    def __init__(self, message: str, raw_response: Optional[str] = None, diagnostics: Optional[PlannerDiagnostics] = None):
        """Initialize JSON extraction error.

        Args:
            message: Error message
            raw_response: Raw LLM response that failed extraction
            diagnostics: Optional diagnostics information
        """
        super().__init__(message)
        self.raw_response = raw_response
        self.diagnostics = diagnostics


class InvalidPlanError(PlanningError):
    """Raised when plan validation fails (schema, tool validation, etc.)."""

    def __init__(self, message: str, validation_errors: Optional[List[str]] = None, diagnostics: Optional[PlannerDiagnostics] = None):
        """Initialize invalid plan error.

        Args:
            message: Error message
            validation_errors: List of validation error details
            diagnostics: Optional diagnostics information
        """
        super().__init__(message)
        self.validation_errors = validation_errors or []
        self.diagnostics = diagnostics


# ============================================================================
# Execution Control Schemas
# ============================================================================


class ExecutionPolicy(BaseModel):
    """Execution policy defining retry and rollback behavior.

    This policy controls how the Executor handles failures. It is immutable
    during execution and does NOT involve any reasoning or intelligence.
    """

    max_retries_per_step: int = Field(
        default=0, ge=0, description="Maximum retries per step (0 = no retries)"
    )
    retry_delay_seconds: float = Field(
        default=0.0, ge=0.0, description="Fixed delay between retries in seconds"
    )
    rollback_on_failure: bool = Field(
        default=False, description="Whether to rollback successful steps on failure"
    )


# ============================================================================
# Execution Result Schemas
# ============================================================================


class StepExecutionResult(BaseModel):
    """Result of executing a single plan step."""

    step_id: int = Field(..., description="Step identifier from plan")
    tool: str = Field(..., description="Tool name used")
    operation: str = Field(..., description="Operation executed")
    arguments: Dict[str, Any] = Field(default_factory=dict, description="Arguments passed to tool")
    success: bool = Field(..., description="Whether step executed successfully")
    output: Optional[Any] = Field(default=None, description="Step output (if successful)")
    error: Optional[str] = Field(default=None, description="Error message (if failed)")
    retries_attempted: int = Field(
        default=0, ge=0, description="Number of retries attempted for this step"
    )
    started_at: float = Field(..., description="Unix timestamp when step started")
    finished_at: float = Field(..., description="Unix timestamp when step finished")


class RollbackStepResult(BaseModel):
    """Result of rolling back a single step."""

    step_id: int = Field(..., description="Step identifier that was rolled back")
    tool: str = Field(..., description="Tool name used for rollback")
    operation: str = Field(..., description="Operation that was rolled back")
    success: bool = Field(..., description="Whether rollback succeeded")
    error: Optional[str] = Field(default=None, description="Error message (if rollback failed)")
    started_at: float = Field(..., description="Unix timestamp when rollback started")
    finished_at: float = Field(..., description="Unix timestamp when rollback finished")


class ExecutionResult(BaseModel):
    """Complete execution result for a plan.

    Always reflects what actually happened during execution, including retries
    and rollback attempts.
    """

    plan_id: str = Field(..., description="Plan identifier")
    objective: str = Field(..., description="Plan objective")
    steps: List[StepExecutionResult] = Field(
        default_factory=list, description="Results for each executed step"
    )
    success: bool = Field(..., description="Whether entire execution succeeded")
    stopped_at_step: Optional[int] = Field(
        default=None, description="Step ID where execution stopped (if failed)"
    )
    rollback_attempted: bool = Field(
        default=False, description="Whether rollback was attempted"
    )
    rollback_success: Optional[bool] = Field(
        default=None, description="Whether rollback succeeded (None if not attempted)"
    )
    rollback_steps: List[RollbackStepResult] = Field(
        default_factory=list, description="Results for each rollback step"
    )
    started_at: float = Field(..., description="Unix timestamp when execution started")
    finished_at: float = Field(..., description="Unix timestamp when execution finished")


class ExecutionError(Exception):
    """Base exception for execution failures."""

    pass


class ToolNotFoundError(ExecutionError):
    """Raised when a requested tool is not found in registry."""

    def __init__(self, tool_name: str):
        """Initialize tool not found error.

        Args:
            tool_name: Name of the tool that was not found
        """
        super().__init__(f"Tool not found: {tool_name}")
        self.tool_name = tool_name


class OperationNotSupportedError(ExecutionError):
    """Raised when a tool does not support the requested operation."""

    def __init__(self, tool_name: str, operation: str):
        """Initialize operation not supported error.

        Args:
            tool_name: Name of the tool
            operation: Operation that is not supported
        """
        super().__init__(f"Operation '{operation}' not supported by tool '{tool_name}'")
        self.tool_name = tool_name
        self.operation = operation

