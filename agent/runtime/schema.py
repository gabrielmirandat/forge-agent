"""Planner output schema definitions.

This module defines the structured output format for the Planner component.
All plans must conform to this schema for validation and execution.
"""

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, field_validator


class ToolName(str, Enum):
    """Allowed tool names."""

    FILESYSTEM = "filesystem"
    GIT = "git"
    GITHUB = "github"
    SHELL = "shell"
    SYSTEM = "system"


class FilesystemOperation(str, Enum):
    """Allowed filesystem operations."""

    READ_FILE = "read_file"
    WRITE_FILE = "write_file"
    LIST_DIRECTORY = "list_directory"
    CREATE_FILE = "create_file"
    DELETE_FILE = "delete_file"


class GitOperation(str, Enum):
    """Allowed Git operations."""

    CREATE_BRANCH = "create_branch"
    COMMIT = "commit"
    PUSH = "push"
    STATUS = "status"
    DIFF = "diff"


class GitHubOperation(str, Enum):
    """Allowed GitHub operations."""

    CREATE_PR = "create_pr"
    LIST_PRS = "list_prs"
    COMMENT_PR = "comment_pr"


class ShellOperation(str, Enum):
    """Allowed shell operations."""

    EXECUTE_COMMAND = "execute_command"


class SystemOperation(str, Enum):
    """Allowed system operations."""

    GET_STATUS = "get_status"
    GET_INFO = "get_info"


# Mapping of tools to their allowed operations
ALLOWED_OPERATIONS: Dict[ToolName, List[str]] = {
    ToolName.FILESYSTEM: [op.value for op in FilesystemOperation],
    ToolName.GIT: [op.value for op in GitOperation],
    ToolName.GITHUB: [op.value for op in GitHubOperation],
    ToolName.SHELL: [op.value for op in ShellOperation],
    ToolName.SYSTEM: [op.value for op in SystemOperation],
}


class PlanStep(BaseModel):
    """A single step in an execution plan."""

    step_id: int = Field(..., description="Sequential step identifier", gt=0)
    tool: ToolName = Field(..., description="Tool name to use")
    operation: str = Field(..., description="Operation to perform")
    arguments: Dict[str, Any] = Field(default_factory=dict, description="Operation arguments")
    rationale: str = Field(..., min_length=1, description="Brief explanation of this step")

    @field_validator("operation", mode="after")
    @classmethod
    def validate_operation(cls, v: str, info) -> str:
        """Validate that operation is allowed for the specified tool."""
        # Get tool from the model instance (info.data is the model instance)
        tool = info.data.get("tool") if hasattr(info, "data") else None
        if tool is None:
            # If tool is not set yet, skip validation (will be validated when tool is set)
            return v

        # Handle both enum and string tool values
        if isinstance(tool, ToolName):
            tool_name = tool
        elif isinstance(tool, str):
            try:
                tool_name = ToolName(tool)
            except ValueError:
                # Tool validation will fail separately, just return operation
                return v
        else:
            return v

        allowed_ops = ALLOWED_OPERATIONS.get(tool_name, [])

        if v not in allowed_ops:
            allowed_str = ", ".join(allowed_ops)
            raise ValueError(
                f"Operation '{v}' is not allowed for tool '{tool_name.value}'. "
                f"Allowed operations: {allowed_str}"
            )

        return v


class Plan(BaseModel):
    """Complete execution plan generated by the Planner."""

    plan_id: str = Field(..., min_length=1, description="Unique plan identifier")
    objective: str = Field(..., min_length=1, description="High-level goal description")
    steps: List[PlanStep] = Field(..., min_length=1, description="Ordered list of execution steps")
    estimated_time_seconds: Optional[int] = Field(
        default=None, ge=0, description="Estimated execution time"
    )
    notes: Optional[str] = Field(
        default=None, description="Additional notes or constraints"
    )

    @field_validator("steps")
    @classmethod
    def validate_step_ids(cls, v: List[PlanStep]) -> List[PlanStep]:
        """Validate that step IDs are sequential and unique."""
        step_ids = [step.step_id for step in v]
        expected_ids = list(range(1, len(v) + 1))

        if step_ids != expected_ids:
            raise ValueError(
                f"Step IDs must be sequential starting from 1. "
                f"Got: {step_ids}, expected: {expected_ids}"
            )

        return v


class PlanningError(Exception):
    """Raised when planning fails."""

    pass


class InvalidPlanError(PlanningError):
    """Raised when plan validation fails."""

    def __init__(self, message: str, validation_errors: Optional[List[str]] = None):
        """Initialize invalid plan error.

        Args:
            message: Error message
            validation_errors: List of validation error details
        """
        super().__init__(message)
        self.validation_errors = validation_errors or []

